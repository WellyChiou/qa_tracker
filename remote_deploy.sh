#!/bin/bash
set -e

# 設置基本路徑和名稱
REMOTE_PATH="/root/project/work"
PROJECT_NAME="docker-vue-java-mysql"
ARCHIVE_NAME="${PROJECT_NAME}.tar.gz"

cd "$REMOTE_PATH"

# 備份證書目錄（如果存在）
CERT_BACKUP_DIR="/tmp/${PROJECT_NAME}_cert_backup"
if [ -d "$PROJECT_NAME/certbot/conf" ]; then
    echo "備份 SSL 證書..."
    rm -rf "$CERT_BACKUP_DIR"
    cp -r "$PROJECT_NAME/certbot/conf" "$CERT_BACKUP_DIR" 2>/dev/null || true
    echo "✅ 證書已備份"
fi

if [ -d "$PROJECT_NAME" ]; then
    if [ -d "${PROJECT_NAME}_backup" ]; then
        rm -rf "${PROJECT_NAME}_backup"
    fi
    mv "$PROJECT_NAME" "${PROJECT_NAME}_backup"
fi

echo "Extracting archive..."
tar -xzf "$ARCHIVE_NAME" 2>&1 | grep -v "Ignoring unknown extended header" || true

REMOTE_DIR=$(tar -tzf "$ARCHIVE_NAME" | head -1 | cut -d'/' -f1)
if [ -d "$REMOTE_DIR" ] && [ "$REMOTE_DIR" != "$PROJECT_NAME" ]; then
    echo "Renaming directory from $REMOTE_DIR to $PROJECT_NAME"
    mv "$REMOTE_DIR" "$PROJECT_NAME"
fi

if [ -d "$PROJECT_NAME" ]; then
    cd "$PROJECT_NAME"
    
    # 恢復證書目錄（如果備份存在且新目錄中沒有證書）
    if [ -d "$CERT_BACKUP_DIR" ] && [ ! -d "certbot/conf/live" ]; then
        echo "恢復 SSL 證書..."
        mkdir -p certbot/conf
        cp -r "$CERT_BACKUP_DIR"/* certbot/conf/ 2>/dev/null || true
        echo "✅ 證書已恢復"
    fi
    
    # Fix Windows line ending issue and make scripts executable
    echo "Fixing line endings and setting permissions..."
    # 使用 sed 移除 Windows 風格的換行符 (\r)
    find . -type f -name "*.sh" -exec sed -i 's/\r$//' {} \;
    # 設置執行權限
    find . -type f -name "*.sh" -exec chmod +x {} \;
    
    # 確保 deploy.sh 有執行權限
    if [ -f "deploy.sh" ]; then
        chmod +x deploy.sh
        # 執行部署
        ./deploy.sh
    else
        echo "❌ 錯誤: 找不到 deploy.sh 文件"
        exit 1
    fi
    
    echo "✅ 遠程部署完成！"
    
    # 步驟 5: 設置預防機制
    # 注意：暫時關閉 set -e，避免預防機制設置失敗影響部署
    set +e
    
    echo ""
    echo "=========================================="
    echo "設置前端白屏預防機制"
    echo "=========================================="
    
    # 獲取當前專案目錄的絕對路徑
    PROJECT_DIR="$(pwd)"

    # 設置日誌目錄和日誌管理
    LOG_DIR="/root/project/work/logs"
    mkdir -p "$LOG_DIR/backend" 2>/dev/null || true
    chmod -R 777 "$LOG_DIR" 2>/dev/null || true
    
    # 获取当前日期（不带时间戳，与 Mac 版本保持一致）
    CURRENT_DATE=$(date +"%Y%m%d")
    
    # 创建当日的日志文件
    touch "$LOG_DIR/frontend-monitor_${CURRENT_DATE}.log" 2>/dev/null || true
    touch "$LOG_DIR/system-monitor_${CURRENT_DATE}.log" 2>/dev/null || true
    chmod 666 "$LOG_DIR"/*.log 2>/dev/null || true
    
    # 确保所有脚本有执行权限
    echo "設置腳本執行權限..."
    chmod +x monitor-frontend.sh monitor-system.sh cleanup-docker.sh fix-frontend.sh diagnose-frontend.sh setup-prevention.sh 2>/dev/null || true
    
    # 檢查並安裝 cron 服務
    echo "檢查並安裝 cron 服務..."
    if ! command -v crontab &> /dev/null; then
        echo "cron 未安裝，嘗試安裝..."
        if command -v apt-get &> /dev/null; then
            echo "使用 apt 安裝 cron..."
            apt-get update && apt-get install -y cron
        elif command -v yum &> /dev/null; then
            echo "使用 yum 安裝 cronie..."
            yum install -y cronie
            systemctl enable crond
            systemctl start crond
        else
            echo "⚠️  無法自動安裝 cron 服務，請手動安裝"
            exit 1
        fi
    fi
    
    # 確保 cron 服務正在運行
    if command -v systemctl &> /dev/null; then
        echo "確保 cron 服務正在運行..."
        systemctl enable cron 2>/dev/null || systemctl enable crond 2>/dev/null || true
        systemctl start cron 2>/dev/null || systemctl start crond 2>/dev/null || true
    fi
    
    
    # 更新 crontab 任務
    echo "正在更新 crontab 任務..."
    
    # 創建臨時 crontab 文件
    TEMP_CRON=$(mktemp)
    
    # 保留現有的非部署相關的 cron 任務
    # 移除所有部署相關的舊任務，避免重複建置
    crontab -l 2>/dev/null | grep -v \
        "monitor-frontend.sh\|monitor-system.sh\|docker system prune\|manage-logs.sh\|找不到\|Auto-generated by deploy" \
        > "$TEMP_CRON" 2>/dev/null || true
    
    # 添加新的 cron 任務（帶註釋便於識別）
    echo "" >> "$TEMP_CRON"
    echo "# ========================================" >> "$TEMP_CRON"
    echo "# 自動部署腳本設置的監控任務" >> "$TEMP_CRON"
    echo "# Auto-generated by deploy script" >> "$TEMP_CRON"
    echo "# 最後更新: $(date +'%Y-%m-%d %H:%M:%S')" >> "$TEMP_CRON"
    echo "# ========================================" >> "$TEMP_CRON"
    echo "" >> "$TEMP_CRON"
    
    # 設置前端監控（每 5 分鐘）
    echo "✅ 設置前端監控（每 5 分鐘檢查一次）..."
    echo "*/5 * * * * cd $PROJECT_DIR && \$PROJECT_DIR/monitor-frontend.sh >> \$LOG_DIR/frontend-monitor_\$(date +%Y%m%d).log 2>&1" >> "$TEMP_CRON"
    
    # 設置系統資源監控（每小時）
    echo "✅ 設置系統資源監控（每小時檢查一次）..."
    echo "0 * * * * cd $PROJECT_DIR && \$PROJECT_DIR/monitor-system.sh >> \$LOG_DIR/system-monitor_\$(date +%Y%m%d).log 2>&1" >> "$TEMP_CRON"
    
    # 設置定期 Docker 清理（每天凌晨 2 點）
    echo "✅ 設置定期 Docker 清理（每天凌晨 2 點）..."
    echo "0 2 * * * cd \$PROJECT_DIR && docker system prune -f && docker image prune -f" >> "$TEMP_CRON"
    
    # 設置日誌清理（每天凌晨 3 點）
    echo "✅ 設置日誌清理（每天凌晨 3 點）..."
    echo "0 3 * * * find \$LOG_DIR -name \"*.log\" -type f -mtime +7 -delete" >> "$TEMP_CRON"
    
    # 安裝更新後的 crontab
    crontab "$TEMP_CRON"
    rm -f "$TEMP_CRON"
    
    # 驗證 crontab 安裝成功
    echo ""
    echo "✅ Crontab 已安裝"
    echo ""
    echo "📋 當前設定的定時任務："
    crontab -l 2>/dev/null | grep -E "monitor-|docker system|\.log.*-delete"
    
    echo ""
    echo "✅ 預防機制設置完成！"
    echo ""
    echo "已設置的監控任務："
    echo "  - 前端監控: 每 5 分鐘檢查一次，自動修復問題"
    echo "  - 系統資源監控: 每小時檢查一次，自動清理資源"
    echo "  - Docker 清理: 每天凌晨 2 點執行"
    echo ""
    
    # 恢復 set -e（如果之前有設置）
    set -e
else
    echo "Error: Cannot find $PROJECT_NAME directory after extraction"
    exit 1
fi
